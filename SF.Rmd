---
title: " An Introduction to Geocoding with 'sf'"
author: "Giulia Maria Petrilli, Julia Wu and Jennifer Estigene"
date: '2023-10-30'
output: 
 html_document:
    toc: TRUE
    df_print: paged
    number_sections: FALSE
    highlight: monochrome
    theme: yeti
    toc_depth: 3
    toc_float: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
library(tidyverse)
library(sf)
#library(tm)
library(tmaptools)
library(geosphere)
library(spData)
library(raster)
library(ggplot2)
library(mapview)


# Put commented out packages that one might want to download 

```


# Introduction 

Geocoding is the process of determining geographic coordinates for place names, street addresses, and zip codes. From information like addresses, city or building names, for example, R fetches the corresponding coordinates and pins it on a map. In this workshop, we will use adopt the standardized way to handle and process spatial data, the "simple features" (sf) package. At the end of our tutorial, you should be familiar with some common verbs used in sf and how to use them for geospatial analysis. 


# Transforming point data to a sf object and plotting on a map 

## st_as_sf() st_cr and mapview()

Let us get to know two important sf functions, st_as_sf() and st_crs(). They often work together. While st_as_sf() is used to convert data frames or matrices into sf objects, st_crs() is used to manage and retrieve the Coordinate Reference System (CRS) of a spatial object. To be clear, an sf object is a special data structure used for working with spatial data, while the CRS defines how the two-dimensional (or three-dimensional) points relate to actual places on the Earth.

Let's see them in action in an example. 

Hertie's international environment makes it so we often work with people from all over the world. Specifically, the three of us that worked on this workshop are from Rome, Tianjin and Ottawa. To get a sense of how far these places actually are from each other, let's plot them on a map. The function mapview() will come in very handy, as it will produces an interactive view of our cities. 

```{r}

cities <- data.frame(
  place = c("Rome", "Tianjin", "Ottawa"),
  long = c(12.496366, 117.190182, -75.690308),  # Longitude of each 
  lat = c(41.902782, 39.084158, 45.421529))      # Latitude of each 
    
cities_dsf <- st_as_sf(cities, coords = c("long", "lat"))  # Makes long and lat into mappable points 
st_crs(cities_dsf) <- 4326  

#The number 4326 is an identifier for a specific Coordinate Reference System (CRS) known as WGS 84. It's like a language code that tells software how to understand and display locations on a map.

mapview(cities_dsf)

```

## geocode_OSM()

Quite cool! But to insert the coordinates feels a bit lenghty, especially when there is a r function that does it for you. I am referring to geocode_OSM()! This function geocodes a location (based on a search query) to coordinates. It uses OpenStreetMap Nominatim; Nominatim ( from the latin "by name") is a search engine for OpenStreetMap (OSM) data.


```{r}

cities_c <- c( "Tianjin", "Rome","Ottawa") 
geocoded_cities <- geocode_OSM(cities_c) 

geocoded_cities

# Create new column using st_as_sf to store the geometry in a column 

geometry_geocoded_cities <- st_as_sf(geocoded_cities,
                      coords = c(x = "lon", y = "lat"),
                      crs = 4326)

geometry_geocoded_cities$CityName <- cities_c # adding the names we want the map to show, more explanatory than addresses and zipcodes 

# Use mapview and specify the zcol parameter to display city names on the legend
mapview(geometry_geocoded_cities, zcol = "CityName")


```


Now, let us add Hertie School and the universities we all went to for our Bachelors, University of Ottawa, Maastricht University and Minerva University (SF, US). To show geocode_OSM's range, we will feed into it as a building name, a zip code and an address respectively. Note how we don't need to go and fetch any API online but geocode_OSM does all the work for us. Let us overlay the two sets of points together on one single map. This will allow us to see all the places in the same map and not on two different ones. Please 

```{r}


bachelors <- geocode_OSM(c("University of Ottawa", "6211 KW", "Market Street, Floor 9, San Francisco"))

geometry_bachelors <- st_as_sf(bachelors, coords = c(x = "lon", y = "lat"), crs = 4326)

university_names <- c("University of Ottawa", "Maastricht University", "Minerva University (SF, US)")
geometry_bachelors$UniName <- university_names 

# Use mapview and specify the zcol parameter to display city names on the legend
mapview(geometry_bachelors, zcol = "UniName")

overlay_map <- mapview(geometry_bachelors, zcol = "UniName") + mapview(geometry_geocoded_cities, zcol = "CityName")

overlay_map



# THE LABELS ARE DIFFERENT COLOURS? CONFUSING 


```



Find places that are closest to each other using st_distance 

```{r}


colnames(geometry_geocoded_cities) <- colnames(geometry_bachelors)  # this otherwise it would not rbind 
rbind(geometry_geocoded_cities, geometry_bachelors)


# Ensure data_sf is in a suitable CRS that uses meters as its units.
# Here, I'm transforming to UTM zone 33N as an example. You might want to choose a more suitable CRS based on your data's location.
data_sf <- rbind(geometry_geocoded_cities, geometry_bachelors)

# If required, transform the CRS to one with meters as units. This is important for distance calculations. 
# (Uncomment next line if needed)
# data_sf_proj <- st_transform(data_sf, crs = 32633)

# Compute the distance matrix
dist_matrix <- st_distance(data_sf)

# To find the pair with the smallest non-zero distance
min_distance_meters <- min(dist_matrix[upper.tri(dist_matrix)])
min_distance_km <- min_distance_meters / 1000  # Convert to kilometers

closest_pair_indices <- which(dist_matrix == min_distance_meters, arr.ind = TRUE)

# Extract the names of the closest cities
city1 <- data_sf$query[closest_pair_indices[1, 1]]
city2 <- data_sf$query[closest_pair_indices[1, 2]]

# Print the names and distance
cat("The closest places are:", city1, "and", city2, "with a distance of", min_distance_km, "km")


```
Distances in number. same code as above but trying to show distances 

In this case this information is available online but with other datasets this might not always be the cas. PLus, we might be in a situation where theres way more data points than we have. 

```{r}

# Ensure data_sf is in a suitable CRS that uses meters as its units.
# Here, I'm transforming to UTM zone 33N as an example. You might want to choose a more suitable CRS based on your data's location.
data_sf_proj <- st_transform(data_sf, crs = 32633)


# Compute the distance matrix
dist_matrix <- st_distance(data_sf_proj)

# To find the pair with the maximum distance
max_distance_meters <- max(dist_matrix)
max_distance_km <- max_distance_meters / 1000  # Convert to kilometers

farthest_pair_indices <- which(dist_matrix == max_distance_meters, arr.ind = TRUE)

# Extract the names of the farthest cities
city1 <- data_sf$query[farthest_pair_indices[1, 1]]
city2 <- data_sf$query[farthest_pair_indices[1, 2]]

# Print the names and distance
cat("The farthest places are:", city1, "and", city2, "with a distance of", max_distance_km, "km")


```


# North Carolina 


Source
https://r-spatial.github.io/sf/articles/sf5.html

```{r}

demo(nc, ask = FALSE, echo = FALSE)
plot(st_geometry(nc))


```
Color key place and size
In case a single attribute is selected, by default a color key is given the side of the plot where it leaves as much as possible room for the plotted map; for nc this is below:

source 
https://r-spatial.github.io/sf/articles/sf5.html


```{r}
plot(nc["AREA"])

```
Let's use st_centroid to find out about the centroids in each region in Corth carolina. Centroids tend to be the areas of easiest reach. For urban planning, infrastructure development, and resource allocation, knowing the centroids of regions can help authorities decide where to build facilities such as roads, schools, hospitals. 

Sources
https://r-spatial.github.io/sf/articles/sf5.html


```{r}

plot(st_geometry(nc), border = 'grey', axes = TRUE) 
plot(st_geometry(st_centroid(nc)), pch = 3, col = 'red', add = TRUE)

```
 
```{r}


# Determine the spatial relationship between different counties
library(sf)
intersections <- st_intersects(nc, nc)
print(intersections)

plot(nc, max.plot = 14)
```

```{r}
# Plot the map of the 'nc' dataset, coloring the polygons based on a specific attribute
plot(nc["BIR74"])
```



```{r}
# Calculate the total population for each county in the 'nc' dataset
total_population <- aggregate(nc[["BIR74"]], by = list(nc[["NAME"]]), FUN = sum)
colnames(total_population) <- c("County", "Total_Population")
head(print(total_population), 15)
```


```{r}
# Find the county with the highest population in the 'nc' dataset
county_highest_population <- total_population[which.max(total_population$Total_Population), ]
print(county_highest_population)

```

```{r}
# Compute the area of each county in square kilometers
area_sq_km <- st_area(nc) / 10^6  # Convert to square kilometers
area_df <- data.frame(NAME = nc$NAME, Area_Sq_Km = area_sq_km)
head(print(area_df), 15)

```


```{r}
# Find the biggest area 
county_biggest <- area_df[which.max(area_df$Area_Sq_Km), ]
print(county_biggest)
```


# World dataset

 
```{r}
# Just showing head otherwise it keeps on running for very long

str(head(world))
```
 
 
```{r}

head(world$continent, 5)
```


```{r}
head(methods(class = 'sf'), 30)
```


```{r}
plot(world['lifeExp'])
```


```{r}


# WHAT IS AFRICA DOING HERE 

africa_sf <- world["continent"][world$continent == "Africa", ]
plot(africa_sf, main = 'Africa', col= NA)

plot(world['pop'])
```


DO WE NEED THIS AS WELL

```{r}
world <- st_transform(world, 3857)
st_crs(world)

library(viridis)
ggplot(world) +
  geom_sf(aes(fill = lifeExp)) +
  scale_fill_viridis("lifeExp") +
  coord_sf(crs = st_crs(4087)) +
  ggtitle("World Equidistant Cylindrical (EPSG 4087)") +
  theme_bw()
```

## References 


 
