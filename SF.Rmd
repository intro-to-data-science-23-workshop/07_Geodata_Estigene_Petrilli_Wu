---
title: " An Introduction to Geocoding with 'sf'"
author: "Giulia Maria Petrilli, Julia Wu and Jennifer Estigene"
date: '2023-10-30'
output: 
 html_document:
    toc: TRUE
    df_print: paged
    number_sections: FALSE
    highlight: monochrome
    theme: yeti
    toc_depth: 3
    toc_float: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
library(tidyverse)
library(sf)
library(tmap)
#library(tm)
library(tmaptools)
library(stringr)
library(rvest)
library(geosphere)
library(nominatim)

library(ggmap)
library(mapview)

           # spatial data classes
library(dplyr)        # data manipulation



#install.packages("stplanr")
library(stplanr)      # transport planning
install.packages("spDataLarge", repos = "https://nowosad.github.io/drat/", type = "source")
library(spDataLarge)  # example datasets

```


## Transforming point data to a sf object

We are from Rome, Tianjin and Ottawa. Let's see where these are on a map 

```{r}

cities <- data.frame(
  place = c("Rome", "Tianjin", "Ottawa"),
  long = c(12.496366, 117.190182, -75.690308),  
  lat = c(41.902782, 39.084158, 45.421529),    
  value = c(500, 600, 700))                     

class(cities)  # WHY DO WE CHECK CLASS

cities_dsf <- st_as_sf(cities, coords = c("long", "lat")) # st_as_sf function is used to convert data, such as a data frame or a matrix, into an sf object. An sf object is a special data structure used for working with spatial data. 
st_crs(cities_dsf) <- 4326
class(cities_dsf)

mapview(cities_dsf)

```

Quite cool! But to insert the coordinates feels a bit lenghty, especially when there is a r function that does it for you/ I am referring to geocode_OSM() 
```{r}

cities_c <- c("Rome", "Tianjin", "Ottawa")
geocoded_cities <- geocode_OSM(cities_c) 

geocoded_cities

# Create new column using st_as_sf to store the geometry in a column 

geometry_geocoded_cities <- st_as_sf(geocoded_cities,
                      coords = c(x = "lon", y = "lat"),
                      crs = 4326)

geometry_geocoded_cities


```


Now, let us add Hertie School and Bocconi and Tsinghua university. we show them on a map 

```{r}


bocconi_hertie_tsinghua <- geocode_OSM(c("Bocconi, Milan", " Hertie School, Berlin", "Tsinghua University, Bejing"))
geometry_bocconi_hertie_tsinghua <- st_as_sf(bocconi_hertie_tsinghua, coords = c(x = "lon", y = "lat"), crs = 4326)

mapview(geometry_bocconi_hertie_tsinghua)



```


We show all on a map 


```{r}
#view(geometry_bocconi_hertie_tsinghua)

overlay_map <- mapview(geometry_bocconi_hertie_tsinghua, zcol = "query") + mapview(geometry_geocoded_cities)
overlay_map


```


Find places that are closest to each other using st_distance 


```{r}

data_sf <- rbind(geometry_geocoded_cities, geometry_bocconi_hertie_tsinghua)
# Compute the distance matrix
dist_matrix <- st_distance(data_sf)

# To find the pair with the smallest non-zero distance
min_distance <- min(dist_matrix[upper.tri(dist_matrix)])
closest_pair_indices <- which(dist_matrix == min_distance, arr.ind = TRUE)

# Extract the names of the closest cities
city1 <- data_sf$query[closest_pair_indices[1, 1]]
city2 <- data_sf$query[closest_pair_indices[1, 2]]

# Print the names
cat("The closest places are:", city1, "and", city2)

```
Farthest places 

```{r}
# Using the same data_sf and computed dist_matrix

# To find the pair with the maximum distance
max_distance <- max(dist_matrix)
farthest_pair_indices <- which(dist_matrix == max_distance, arr.ind = TRUE)

# Extract the names of the farthest cities
city1 <- data_sf$query[farthest_pair_indices[1, 1]]
city2 <- data_sf$query[farthest_pair_indices[1, 2]]

# Print the names
cat("The farthest places are:", city1, "and", city2)


```
Distances in number. same code as above but trying to show distances 

```{r}

# Ensure data_sf is in a suitable CRS that uses meters as its units.
# Here, I'm transforming to UTM zone 33N as an example. You might want to choose a more suitable CRS based on your data's location.
data_sf_proj <- st_transform(data_sf, crs = 32633)


?st_transform

# Compute the distance matrix
dist_matrix <- st_distance(data_sf_proj)

# To find the pair with the maximum distance
max_distance_meters <- max(dist_matrix)
max_distance_km <- max_distance_meters / 1000  # Convert to kilometers

farthest_pair_indices <- which(dist_matrix == max_distance_meters, arr.ind = TRUE)

# Extract the names of the farthest cities
city1 <- data_sf$query[farthest_pair_indices[1, 1]]
city2 <- data_sf$query[farthest_pair_indices[1, 2]]

# Print the names and distance
cat("The farthest places are:", city1, "and", city2, "with a distance of", max_distance_km, "km")


```


## North Carolina 


Source
https://r-spatial.github.io/sf/articles/sf5.html

```{r}

demo(nc, ask = FALSE, echo = FALSE)
plot(st_geometry(nc))


```
Color key place and size
In case a single attribute is selected, by default a color key is given the side of the plot where it leaves as much as possible room for the plotted map; for nc this is below:

source 
https://r-spatial.github.io/sf/articles/sf5.html


```{r}
plot(nc["AREA"])

```
Let's use st_centroid to find out about the centroids in each region in Corth carolina. Centroids tend to be the areas of easiest reach. For urban planning, infrastructure development, and resource allocation, knowing the centroids of regions can help authorities decide where to build facilities such as roads, schools, hospitals. 

Sources
https://r-spatial.github.io/sf/articles/sf5.html


```{r}


plot(st_geometry(nc), border = 'grey', axes = TRUE) 
plot(st_geometry(st_centroid(nc)), pch = 3, col = 'red', add = TRUE)




```
 
 
 
## Bristol origin-destination data


The data used in this example is sourced from Lovelace, Nowosad, and Muenchow (2019). It concerns to origin-destination (OD) counts, which represent the number of individuals traveling from Zone A to Zone B using different modes of transportation. The feature geometries for the 102 origin and destination areas are contained in the 'sf' object named 'bristol_zones', and are depicted in the following figure. 

Sources 

https://cran.r-project.org/web/packages/spData/readme/README.html # for info on how to download spDataLarge with all the datasets 
https://r-spatial.org/book/07-Introsf.html


```{r}

plot(st_geometry(bristol_zones), axes = TRUE, graticule = TRUE)



```



```{r}
head(bristol_od)

nrow(bristol_zones)^2 - nrow(bristol_od) 
bristol_tidy <- bristol_od |> 
    select(-all) |> 
    pivot_longer(3:6, names_to = "mode", values_to = "n")

head(bristol_tidy)

od <- bristol_tidy |> pull("o") |> unique()
nod <- length(od)
mode <- bristol_tidy |> pull("mode") |> unique()
nmode = length(mode)
a = array(0L,  c(nod, nod, nmode), 
    dimnames = list(o = od, d = od, mode = mode))
dim(a)


a[as.matrix(bristol_tidy[c("o", "d", "mode")])] <- 
        bristol_tidy$n


order <- match(od, bristol_zones$geo_code)
zones <- st_geometry(bristol_zones)[order]

?stars()

library(stars)
(d <- st_dimensions(o = zones, d = zones, mode = mode))

(odm <- st_as_stars(list(N = a), dimensions = d))

plot(adrop(odm[,,33]) + 1, logz = TRUE)

```
 

